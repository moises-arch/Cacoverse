{% doc %}
  @prompt
    generate a fully functional announcement bar with scrolling and fade in and fade out effect. 
    
    up to 4 messages full adjustable with color, font weight, etc 
    
    
{% enddoc %}
{% assign ai_gen_id = block.id | replace: '_', '' | downcase %}

<style>








/* Glassy dark + blur */
.ai-announcement-bar-{{ ai_gen_id }}{
  position: relative;
  color: #fff !important;
}



.ai-announcement-bar-{{ ai_gen_id }}::before{
  content:"";
  position:absolute; inset:0;
  background: #1c63a0;           /* ← QUITÉ el ); */
  -webkit-backdrop-filter: blur(10px) saturate(140%);
  backdrop-filter: blur(10px) saturate(140%);
  z-index:0;
  box-shadow: 0 0px 10px #222; /* ← QUITÉ el ); */
}



/* === Z-LAYER FIX: bar debajo de header, drawers, modales === */

/* Regla base: crea su propio stacking context y baja el nivel */
.ai-announcement-bar-{{ ai_gen_id }}{
  position: relative;
  isolation: isolate;
  z-index: 50 !important;           /* antes estaba en 1000; 50 es sano */
}

/* El fondo blur sigue debajo del texto */
.ai-announcement-bar-{{ ai_gen_id }}::before{ z-index: 0; }
.ai-announcement-bar-container-{{ ai_gen_id }},
.ai-marquee-viewport-{{ ai_gen_id }},
.ai-rotator-container-{{ ai_gen_id }},
.ai-announcement-message-{{ ai_gen_id }},
.ai-announcement-close-{{ ai_gen_id }}{ z-index: 1; position: relative; }

/* En caso de que algún tema le meta fixed al bar en otro lado (defensivo) */
.ai-announcement-bar-{{ ai_gen_id }}[style*="position: fixed"],
.ai-announcement-bar-{{ ai_gen_id }}.is-fixed{
  position: relative !important;
  top: auto !important; left: auto !important; right: auto !important;
}

/* Sugerencia de escalera global (pon en tu hoja base si quieres orden zen)
:root{
  --z-announcement: 50;
  --z-header: 1000;
  --z-drawer: 1050;
  --z-overlay: 1400;
  --z-modal: 2000;
}
.site-header{ z-index: var(--z-header,1000) !important; position: sticky; }
.cart-drawer, .nav-drawer{ z-index: var(--z-drawer,1050) !important; }
.modal, .modal-backdrop{ z-index: var(--z-modal,2000) !important; }










/* Asegura el contenido por encima */
.ai-announcement-bar-container-{{ ai_gen_id }},
.ai-marquee-viewport-{{ ai_gen_id }},
.ai-rotator-container-{{ ai_gen_id }},
.ai-announcement-message-{{ ai_gen_id }},
.ai-announcement-close-{{ ai_gen_id }}{ position:relative; z-index:1; }

/* Fallback si no hay soporte de blur */
@supports not ((-webkit-backdrop-filter: blur(2px)) or (backdrop-filter: blur(2px))){
  .ai-announcement-bar-{{ ai_gen_id }}::before{ background: rgba(16,20,24,.92); }
}



  /* --- Root bar --- */
  .ai-announcement-bar-{{ ai_gen_id }} {
    position: relative;
    width: 100%;
    background-color: {{ block.settings.background_color }};
    color: {{ block.settings.text_color }};
    font-family: {{ block.settings.font_family.family }}, {{ block.settings.font_family.fallback_families }};
    font-weight: {{ block.settings.font_weight }};
    font-size: {{ block.settings.font_size }}px;
    line-height: 1.4;
    overflow: hidden;
    z-index: 1000;
  }

  .ai-announcement-bar-container-{{ ai_gen_id }} {
    width: 100%;
    height: {{ block.settings.bar_height }}px;
    display: flex;
    align-items: center;
    position: relative;
    box-sizing: border-box;
    padding: 0 {{ block.settings.horizontal_padding }}px;
  }

  /* --- Track for continuous marquee --- */
  .ai-marquee-viewport-{{ ai_gen_id }} {
    overflow: hidden;
    width: 98%;
  }

  .ai-marquee-track-{{ ai_gen_id }} {
    display: inline-flex;
    align-items: center;
    gap: 40px; /* espacio entre mensajes: configurable si quieres */
    white-space: nowrap;
    will-change: transform;
    --marquee-duration: {{ block.settings.scroll_speed }}s;
    animation-play-state: running;
  }

  .ai-marquee-track-{{ ai_gen_id }}.is-animated {
    animation: ai-marquee-anim-{{ ai_gen_id }} var(--marquee-duration) linear infinite;
  }

  .ai-announcement-message-{{ ai_gen_id }} {
    display: inline-block;
    white-space: nowrap;
    padding: 0 6px;
    text-align: left;
  }

  @keyframes ai-marquee-anim-{{ ai_gen_id }} {
    0% { transform: translateX(0); }
    100% { transform: translateX(-50%); } /* -50% porque duplicamos contenido */
  }

  /* --- Fallback (fade/rotate) --- */
  .ai-rotator-container-{{ ai_gen_id }} { position: relative; width: 100%; height: 100%; }
  .ai-rotator-message-{{ ai_gen_id }} { 
    position: absolute; 
    left: 0; right:0; 
    top: 50%; transform: translateY(-50%);
    opacity: 0; transition: opacity {{ block.settings.fade_duration }}s ease-in-out;
    text-align: center;
    white-space: nowrap;
  }
  .ai-rotator-message-{{ ai_gen_id }}.active { opacity: 1; }

  /* --- Close button --- */
  .ai-announcement-close-{{ ai_gen_id }} {
    position: absolute;
    top: 50%;
    right: {{ block.settings.horizontal_padding }}px;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: {{ block.settings.text_color }};
    cursor: pointer;
    padding: 4px;
    opacity: 0.8;
    z-index: 10;
  }

  .ai-announcement-close-{{ ai_gen_id }}:hover { opacity: 1; }

  /* --- Responsive tweaks --- */
  @media screen and (max-width: 749px) {
    .ai-announcement-bar-{{ ai_gen_id }} { font-size: {{ block.settings.font_size | times: 0.9 }}px; }
    .ai-announcement-bar-container-{{ ai_gen_id }} { height: {{ block.settings.bar_height | times: 0.9 }}px; padding: 0 {{ block.settings.horizontal_padding | times: 0.7 }}px; }
  }

  /* Prevent selection while dragging */
  .ai-marquee-track-{{ ai_gen_id }}, .ai-announcement-message-{{ ai_gen_id }} { -webkit-user-select:none; -ms-user-select:none; user-select:none; }
</style>

<announcement-bar-{{ ai_gen_id }}
  class="ai-announcement-bar-{{ ai_gen_id }}"
  data-enable-scrolling="{{ block.settings.enable_scrolling }}"
  data-scroll-speed="{{ block.settings.scroll_speed }}"
  data-scroll-gap="40"
  data-auto-rotate="{{ block.settings.auto_rotate }}"
  data-rotation-interval="{{ block.settings.rotation_interval }}"
  data-fade-duration="{{ block.settings.fade_duration }}"
  {{ block.shopify_attributes }}
>
  <div class="ai-announcement-bar-container-{{ ai_gen_id }}">
    <!-- Marquee viewport (used when scrolling enabled) -->
    <div class="ai-marquee-viewport-{{ ai_gen_id }}">
      <div class="ai-marquee-track-{{ ai_gen_id }}" aria-hidden="false">
        {% for i in (1..4) %}
          {% liquid
            assign message_key = 'message_' | append: i
            assign enabled_key = 'message_' | append: i | append: '_enabled'
            assign message = block.settings[message_key]
            assign enabled = block.settings[enabled_key]
          %}
          {% if enabled and message != blank %}
            <div class="ai-announcement-message-{{ ai_gen_id }}" data-message-index="{{ forloop.index0 }}">
              {{ message }}
            </div>
          {% endif %}
        {% endfor %}
      </div>
    </div>

    <!-- Rotator fallback (used when scrolling disabled) -->
    <div class="ai-rotator-container-{{ ai_gen_id }}" style="display:none;">
      {% for i in (1..4) %}
        {% liquid
          assign message_key = 'message_' | append: i
          assign enabled_key = 'message_' | append: i | append: '_enabled'
          assign message = block.settings[message_key]
          assign enabled = block.settings[enabled_key]
        %}
        {% if enabled and message != blank %}
          <div class="ai-rotator-message-{{ ai_gen_id }}" data-rot-index="{{ forloop.index0 }}">{{ message }}</div>
        {% endif %}
      {% endfor %}
    </div>

    {% if block.settings.show_close_button %}
      <button class="ai-announcement-close-{{ ai_gen_id }}" aria-label="Close announcement">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:16px;height:16px;">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    {% endif %}
  </div>
</announcement-bar-{{ ai_gen_id }}>




<script>
  (function(){
    class AnnouncementBar{{ ai_gen_id }} extends HTMLElement {
      constructor(){ 
        super(); 
        this.marqueeTrack = null; 
        this.viewport = null; 
        this.messages = []; 
        this.isAnimated = false; 
        this.rotationTimer = null; 
        this.currentIndex = 0; 
        this.scrollGap = 40;
      }
      connectedCallback(){ this.init(); }
      disconnectedCallback(){ if(this.rotationTimer) clearInterval(this.rotationTimer); }

      init(){
        this.enableScrolling = this.dataset.enableScrolling === 'true';
        this.scrollSpeed = parseFloat(this.dataset.scrollSpeed) || 15;
        this.scrollGap = parseInt(this.dataset.scrollGap) || 40;
        this.autoRotate = this.dataset.autoRotate === 'true';
        this.rotationInterval = (parseInt(this.dataset.rotationInterval)||5) * 1000;
        this.fadeDuration = (parseFloat(this.dataset.fadeDuration)||0.5) * 1000;

        this.viewport = this.querySelector('.ai-marquee-viewport-{{ ai_gen_id }}');
        this.marqueeTrack = this.querySelector('.ai-marquee-track-{{ ai_gen_id }}');
        this.rotatorContainer = this.querySelector('.ai-rotator-container-{{ ai_gen_id }}');

        // Close button
        const closeBtn = this.querySelector('.ai-announcement-close-{{ ai_gen_id }}');
        if (closeBtn) closeBtn.addEventListener('click', ()=> this.hide());

        // Collect message nodes
        this.messages = Array.from(this.querySelectorAll('.ai-announcement-message-{{ ai_gen_id }}'));

        // If no messages, hide
        if (this.messages.length === 0) { this.style.display = 'none'; return; }

        if (this.enableScrolling && this.messages.length >= 1) {
          // show marquee, hide rotator
          this.viewport.style.display = '';
          if (this.rotatorContainer) this.rotatorContainer.style.display = 'none';

          // Duplicate track content for seamless loop (and ensure it fills viewport)
          this.duplicateUntilFull();

          // Set animation duration and gap (CSS variables)
          this.marqueeTrack.style.setProperty('--marquee-duration', this.scrollSpeed + 's');
          this.marqueeTrack.style.setProperty('--marquee-gap', this.scrollGap + 'px');

          // Always start animation (now it runs immediately)
          // small timeout to allow layout/paint before starting animation
          setTimeout(()=> {
            this.marqueeTrack.classList.add('is-animated');
            this.isAnimated = true;
          }, 80);

          // Pause on hover
          this.viewport.addEventListener('mouseenter', ()=> this.pauseMarquee(true));
          this.viewport.addEventListener('mouseleave', ()=> this.pauseMarquee(false));

          // Recompute on resize (keep animation running)
          this._resizeHandler = ()=> this.onResize();
          window.addEventListener('resize', this._resizeHandler);
        } else {
          // fallback: rotator (fade)
          if (this.viewport) this.viewport.style.display = 'none';
          if (this.rotatorContainer) this.rotatorContainer.style.display = '';
          this.rotatorMessages = Array.from(this.querySelectorAll('.ai-rotator-message-{{ ai_gen_id }}'));
          if (this.rotatorMessages.length > 0) {
            this.showRotatorMessage(0);
            if (this.autoRotate && this.rotatorMessages.length > 1) this.startRotation();
          }
        }
      }

      duplicateUntilFull(){
        if (!this.marqueeTrack || !this.viewport) return;
        // Get initial markup of the original set (only non-clone children)
        const originalHTML = Array.from(this.marqueeTrack.children)
          .filter(n => !n.hasAttribute('data-clone'))
          .map(n => n.outerHTML)
          .join('');

        // Ensure at least one duplication exists (we need duplicates for seamless loop)
        // Remove previous clones if any, keep only the original first set
        const originals = Array.from(this.marqueeTrack.children).filter(n => !n.hasAttribute('data-clone'));
        this.marqueeTrack.innerHTML = originals.map(n => n.outerHTML).join('');

        // Append one duplicate at minimum
        if (originals.length > 0) {
          const cloneOnce = originals.map(n => n.outerHTML).join('');
          const firstClone = cloneOnce;
          this.marqueeTrack.insertAdjacentHTML('beforeend', firstClone);
        }

        // Now, if the single set width is still less than viewport, keep appending the original set
        let repeats = 0;
        const maxRepeats = 5; // safety cap
        // Force layout measurement
        const ensureMeasure = () => {
          // allow browser to layout
          return new Promise(resolve => requestAnimationFrame(resolve));
        };

        const checkAndRepeat = async () => {
          await ensureMeasure();
          let trackWidth = this.marqueeTrack.scrollWidth;
          let viewportWidth = this.viewport.clientWidth || document.documentElement.clientWidth;
          // singleSetWidth is half the track width because we appended one duplicate
          let singleSetWidth = trackWidth / 2;

          while (singleSetWidth < viewportWidth && repeats < maxRepeats) {
            // append originalHTML again
            this.marqueeTrack.insertAdjacentHTML('beforeend', originalHTML);
            repeats++;
            // allow layout update
            await ensureMeasure();
            trackWidth = this.marqueeTrack.scrollWidth;
            singleSetWidth = trackWidth / (repeats + 2); // approx: original sets count
          }

          // mark all appended nodes as clones for easier cleanup later
          Array.from(this.marqueeTrack.children).forEach((n, idx) => {
            if (idx >= (this.messages.length)) n.setAttribute('data-clone', 'true');
          });
        };

        // start async check (non-blocking)
        checkAndRepeat();
      }

      pauseMarquee(shouldPause){
        if (!this.marqueeTrack) return;
        this.marqueeTrack.style.animationPlayState = shouldPause ? 'paused' : 'running';
      }

      onResize(){
        // Keep the animation running; but ensure the track still fills viewport.
        // If viewport grew and now single set > viewport, we can add duplicates if needed.
        if (!this.marqueeTrack || !this.viewport) return;
        // Re-run duplicateUntilFull to ensure coverage (it has safety caps)
        this.duplicateUntilFull();
        // Always keep animation class
        this.marqueeTrack.classList.add('is-animated');
        this.pauseMarquee(false);
      }

      hide(){
        this.style.display = 'none';
        if (this.rotationTimer) clearInterval(this.rotationTimer);
        window.removeEventListener('resize', this._resizeHandler);
      }

      /* Rotator fallback methods */
      showRotatorMessage(index){
        this.rotatorMessages.forEach((m,i) => m.classList.toggle('active', i === index));
        this.currentIndex = index;
      }
      startRotation(){
        this.rotationTimer = setInterval(()=>{
          const next = (this.currentIndex + 1) % this.rotatorMessages.length;
          this.showRotatorMessage(next);
        }, this.rotationInterval);
      }
    }

    customElements.define('announcement-bar-{{ ai_gen_id }}', AnnouncementBar{{ ai_gen_id }});
  })();
</script>
















<announcement-bar-{{ ai_gen_id }}
  class="ai-announcement-bar-{{ ai_gen_id }}"
  data-auto-rotate="{{ block.settings.auto_rotate }}"
  data-rotation-interval="{{ block.settings.rotation_interval }}"
  data-enable-scrolling="{{ block.settings.enable_scrolling }}"
  data-scroll-threshold="{{ block.settings.scroll_threshold }}"
  data-fade-duration="{{ block.settings.fade_duration }}"
  {{ block.shopify_attributes }}
>
  <div class="ai-announcement-bar-container-{{ ai_gen_id }}">
    <div class="ai-announcement-bar-content-{{ ai_gen_id }}">
      {% for i in (1..4) %}
        {% liquid
          assign message_key = 'message_' | append: i
          assign enabled_key = 'message_' | append: i | append: '_enabled'
          assign message = block.settings[message_key]
          assign enabled = block.settings[enabled_key]
        %}
        
        {% if enabled and message != blank %}
          <div 
            class="ai-announcement-message-{{ ai_gen_id }}"
            data-message-index="{{ forloop.index0 }}"
          >
            {{ message }}
          </div>
        {% endif %}
      {% endfor %}
      
      {% if block.settings.show_close_button %}
        <button 
          class="ai-announcement-close-{{ ai_gen_id }}"
          aria-label="Close announcement"
        >
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      {% endif %}
    </div>
  </div>
</announcement-bar-{{ ai_gen_id }}>

<script>
  (function() {
    class AnnouncementBar{{ ai_gen_id }} extends HTMLElement {
      constructor() {
        super();
        this.messages = [];
        this.currentIndex = 0;
        this.rotationTimer = null;
        this.isScrolling = false;
      }

      connectedCallback() {
        this.init();
      }

      disconnectedCallback() {
        if (this.rotationTimer) {
          clearInterval(this.rotationTimer);
        }
      }

      init() {
        this.messages = Array.from(this.querySelectorAll('.ai-announcement-message-{{ ai_gen_id }}'));
        
        if (this.messages.length === 0) return;

        this.autoRotate = this.dataset.autoRotate === 'true';
        this.rotationInterval = parseInt(this.dataset.rotationInterval) * 1000;
        this.enableScrolling = this.dataset.enableScrolling === 'true';
        this.scrollThreshold = parseInt(this.dataset.scrollThreshold);
        this.fadeDuration = parseFloat(this.dataset.fadeDuration) * 1000;

        this.setupCloseButton();
        this.checkScrolling();
        this.showMessage(0);
        
        if (this.autoRotate && this.messages.length > 1) {
          this.startRotation();
        }

        window.addEventListener('resize', () => this.checkScrolling());
      }

      setupCloseButton() {
        const closeButton = this.querySelector('.ai-announcement-close-{{ ai_gen_id }}');
        if (closeButton) {
          closeButton.addEventListener('click', () => {
            this.classList.add('hidden');
            if (this.rotationTimer) {
              clearInterval(this.rotationTimer);
            }
          });
        }
      }

      checkScrolling() {
        if (!this.enableScrolling) return;

        this.messages.forEach((message, index) => {
          const messageWidth = message.scrollWidth;
          const containerWidth = this.querySelector('.ai-announcement-bar-content-{{ ai_gen_id }}').clientWidth;
          
          if (messageWidth > containerWidth - this.scrollThreshold) {
            message.classList.add('scrolling');
          } else {
            message.classList.remove('scrolling');
          }
        });
      }

      showMessage(index) {
        if (index >= this.messages.length) return;

        this.messages.forEach((message, i) => {
          if (i === index) {
            message.classList.add('active');
          } else {
            message.classList.remove('active');
          }
        });

        this.currentIndex = index;
      }

      startRotation() {
        this.rotationTimer = setInterval(() => {
          this.fadeOut(() => {
            const nextIndex = (this.currentIndex + 1) % this.messages.length;
            this.showMessage(nextIndex);
          });
        }, this.rotationInterval);
      }

      fadeOut(callback) {
        const currentMessage = this.messages[this.currentIndex];
        if (currentMessage) {
          currentMessage.classList.remove('active');
          setTimeout(callback, this.fadeDuration);
        } else {
          callback();
        }
      }
    }

    customElements.define('announcement-bar-{{ ai_gen_id }}', AnnouncementBar{{ ai_gen_id }});
  })();
</script>

{% schema %}
{
  "name": "Announcement bar",
  "tag": null,
  "settings": [
    {
      "type": "header",
      "content": "Messages"
    },
    {
      "type": "checkbox",
      "id": "message_1_enabled",
      "label": "Enable message 1",
      "default": true
    },
    {
      "type": "text",
      "id": "message_1",
      "label": "Message 1",
      "default": "Free shipping on orders over $50!"
    },
    {
      "type": "checkbox",
      "id": "message_2_enabled",
      "label": "Enable message 2",
      "default": false
    },
    {
      "type": "text",
      "id": "message_2",
      "label": "Message 2"
    },
    {
      "type": "checkbox",
      "id": "message_3_enabled",
      "label": "Enable message 3",
      "default": false
    },
    {
      "type": "text",
      "id": "message_3",
      "label": "Message 3"
    },
    {
      "type": "checkbox",
      "id": "message_4_enabled",
      "label": "Enable message 4",
      "default": false
    },
    {
      "type": "text",
      "id": "message_4",
      "label": "Message 4"
    },
    {
      "type": "header",
      "content": "Behavior"
    },
    {
      "type": "checkbox",
      "id": "auto_rotate",
      "label": "Auto rotate messages",
      "default": true
    },
    {
      "type": "range",
      "id": "rotation_interval",
      "min": 2,
      "max": 15,
      "step": 1,
      "unit": "s",
      "label": "Rotation interval",
      "default": 5
    },
    {
      "type": "checkbox",
      "id": "enable_scrolling",
      "label": "Enable scrolling for long messages",
      "default": true
    },
    {
      "type": "range",
      "id": "scroll_threshold",
      "min": 50,
      "max": 200,
      "step": 10,
      "unit": "px",
      "label": "Scroll threshold",
      "default": 100
    },
    {
      "type": "range",
      "id": "fade_duration",
      "min": 0.1,
      "max": 2,
      "step": 0.1,
      "unit": "s",
      "label": "Fade duration",
      "default": 0.5
    },
    {
      "type": "range",
      "id": "scroll_speed",
      "min": 5,
      "max": 80,
      "step": 1,
      "unit": "s",
      "label": "Scroll speed",
      "default": 15
    },
    {
      "type": "checkbox",
      "id": "show_close_button",
      "label": "Show close button",
      "default": true
    },
    {
      "type": "header",
      "content": "Style"
    },
    {
      "type": "color",
      "id": "background_color",
      "label": "Background color",
      "default": "#000000"
    },
    {
      "type": "color",
      "id": "text_color",
      "label": "Text color",
      "default": "#ffffff"
    },
    {
      "type": "font_picker",
      "id": "font_family",
      "label": "Font family",
      "default": "barlow_n4"
    },
    {
      "type": "select",
      "id": "font_weight",
      "label": "Font weight",
      "options": [
        {
          "value": "300",
          "label": "Light"
        },
        {
          "value": "400",
          "label": "Normal"
        },
        {
          "value": "500",
          "label": "Medium"
        },
        {
          "value": "600",
          "label": "Semi bold"
        },
        {
          "value": "700",
          "label": "Bold"
        }
      ],
      "default": "400"
    },
    {
      "type": "range",
      "id": "font_size",
      "min": 12,
      "max": 24,
      "step": 1,
      "unit": "px",
      "label": "Font size",
      "default": 14
    },
    {
      "type": "range",
      "id": "bar_height",
      "min": 30,
      "max": 80,
      "step": 2,
      "unit": "px",
      "label": "Bar height",
      "default": 40
    },
    {
      "type": "range",
      "id": "horizontal_padding",
      "min": 10,
      "max": 50,
      "step": 2,
      "unit": "px",
      "label": "Horizontal padding",
      "default": 20
    }
  ],
  "presets": [
    {
      "name": "Announcement bar"
    }
  ]
}
{% endschema %}