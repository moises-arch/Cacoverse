<script>
  document.addEventListener('DOMContentLoaded', function() {
    const sectionId = '{{ section.id }}';
    const formId = 'product-form-' + sectionId;
    const qtyInput = document.getElementById(`Quantity-${sectionId}`);
    
    if (!qtyInput) return;

    // Robust Money Formatter
    function formatMoney(cents, format) {
      if (typeof cents === 'string') cents = cents.replace('.', '');
      let value = '';
      const placeholderRegex = /\{\{\s*(\w+)\s*\}\}/;
      const formatString = format || '{{amount}}';

      function defaultOption(opt, def) {
        return (typeof opt == 'undefined' ? def : opt);
      }

      function formatWithDelimiters(number, precision, thousands, decimal) {
        precision = defaultOption(precision, 2);
        thousands = defaultOption(thousands, ',');
        decimal = defaultOption(decimal, '.');

        if (isNaN(number) || number == null) { return 0; }

        number = (number / 100).toFixed(precision);

        var parts = number.split('.');
        var dollars = parts[0].replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + thousands);
        var cents = parts[1] ? (decimal + parts[1]) : '';

        return dollars + cents;
      }

      const match = formatString.match(placeholderRegex);
      if (!match) return '$' + (cents/100).toFixed(2); // Fallback

      switch(match[1]) {
        case 'amount':
          value = formatWithDelimiters(cents, 2);
          break;
        case 'amount_no_decimals':
          value = formatWithDelimiters(cents, 0);
          break;
        case 'amount_with_comma_separator':
          value = formatWithDelimiters(cents, 2, '.', ',');
          break;
        case 'amount_no_decimals_with_comma_separator':
          value = formatWithDelimiters(cents, 0, '.', ',');
          break;
        default:
          value = formatWithDelimiters(cents, 2);
      }

      return formatString.replace(placeholderRegex, value);
    }

    // Default button text
    const defaultText = {{ 'products.product.add_to_cart' | t | json }};
    const moneyFormat = {{ shop.money_format | json }};

    function updateAddToCartButton() {
      // Delay slightly for React/Theme updates
      setTimeout(() => {
        const qty = parseInt(qtyInput.value) || 1;
        
        // Find the checkout button
        const btn = document.getElementById(`ProductSubmitButton-${sectionId}`);
        if (!btn || btn.hasAttribute('disabled')) return; 
        
        const btnTextSpan = btn.querySelector('span');
        if (!btnTextSpan) return;

         // Reset if qty is 1
        if (qty <= 1) {
             btnTextSpan.textContent = defaultText;
             return;
        }

        // Get pricing data
        const internalDataScript = document.getElementById(`VariantSubscription-${sectionId}`);
        let variantData = null;
        
        if (internalDataScript) {
          try {
            variantData = JSON.parse(internalDataScript.textContent);
          } catch(e) {}
        }

        // Scoped variant lookup
        const productForm = document.getElementById(formId);
        let currentVariantId = '{{ product.selected_or_first_available_variant.id }}';

        if (productForm) {
            const variantInput = productForm.querySelector('input[name="id"]');
            if (variantInput) currentVariantId = variantInput.value;
        }
        
        // Determine price
        let basePrice = 0;
        
        if (variantData && variantData[currentVariantId]) {
             // We have subscription data
            const data = variantData[currentVariantId];
            const subRadio = document.querySelector(`input[name="purchase_option"][value="subscription"]`);
            const isSub = subRadio && subRadio.checked;
            basePrice = isSub ? data.subscription : data.onetime;
        } else {
            // Fallback to basic variant data if sub data missing
            // (Note: This might not account for changing variants if not in the JSON, but basic robustness)
            // Ideally we'd read it from the DOM or a global object, but let's stick to initial logic
             // Try to parse from a "data-price" if available, or just ignore update
             return; 
        }

        const total = basePrice * qty;
        const formattedTotal = formatMoney(total, moneyFormat);

        // Update button text
        btnTextSpan.textContent = `${defaultText} - ${formattedTotal}`;

      }, 50);
    }

    // Event Listeners
    qtyInput.addEventListener('input', updateAddToCartButton);
    qtyInput.addEventListener('change', updateAddToCartButton);
    
    // Purchase option toggles (One-time vs Sub)
    const radios = document.querySelectorAll(`input[name="purchase_option"]`);
    radios.forEach(r => r.addEventListener('change', updateAddToCartButton));

    // Quantity buttons
    const wrapper = qtyInput.closest('quantity-input');
    if (wrapper) {
      wrapper.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', updateAddToCartButton);
      });
    }
    
    // Variant changes
    document.addEventListener('variant:change', () => setTimeout(updateAddToCartButton, 100));
    
    // Initial Run
    updateAddToCartButton();
  });
</script>
